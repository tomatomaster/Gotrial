y 0001
^単項で使用するとビット反転     ^y 1110
# bit演算
x 1011
&^二項演算子で使用するとビット差   x&^y 1010


# bigの計算
var x,y big.Rat
x.Add(&x,&y) //xを書き換える。

javaの場合bigIntergerに対するaddはGoで言うと下記のようになっている
レシーバー(z)と第一引数(x)が異なるため、加算されるごとにメモリ消費量が増える
したがって、Goはレシーバーと第一引数が一致している場合メモリ効率が良い
x,y,z big.Rat
z.Add(&x,&y)

UTF-8は自己同期化される
そもそも同期とは？
例えばCPUアーキテクチャデータバスはバイト列の区切りをどのように判断しているのか
CPUクロックを見てデータの区切りを判断している。つまり、データバスは自己では同期できていない

```イメージ
　　　　　　 0|0|1|0|0|
CPUクロック  ^ ^ ^ ^ ^
```

この意味で、UTF-8はそれ自身でデータの区切りがわかるフォーマットのため自己同期化されていると言える

# Sprintfとstrconv.Itoaどちらを使うべきか
Sprintfは空interfaceを引数に持つ汎用品のため、内部的に
リフレクションを使用しているので、遅い。
たの文字列と組み合わせて使うときはSprintfで良いが、単一の文字列ならItoaで良いのでは


# Goのコンパイル環境
go env goに関する環境変数の表示

[GO_ROOT_BOOTSTRAP Go 1.7.1]を利用して、[~/tools/go/src]にある最新のコンパイラ[仮にNCompとする]が作成される。このNCompを利用して、残りの[~/tools/go/src]ソースコードをコンパイルする。

初期の頃はこのBootStarpコンパイラがC言語で書かれていた。

[~/tools/go/src]内のinternalは外からさわれないパッケージ
vendarパッケージは3rdベンダーのソースコードを丸々取り込んでいるもの
丸々自分たちの領域に取り込むことで、goだけあれば動作することを保証している

# Rune int32
Runeとint32は全く一緒の型

