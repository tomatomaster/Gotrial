
```go
for py := 0; py < height; py++ {
	y := float64(py)/height*(ymax-ymin) + ymin
	fmt.Printf("py=%v y=%v \n", py, y)
}
```

```
py=0 y=-2 
py=1 y=-1.99609375 
py=2 y=-1.9921875 
py=3 y=-1.98828125 
py=4 y=-1.984375 
py=5 y=-1.98046875 
```

goの&&や||は左オペランドで答えが出ていれば右オペランドを評価しない
下記の例で、s = ""ならばこの時点で、式がfalseであることが確定するため、右オペランドであるs[0] == 'x'を評価しない

```go
//もし、s == ""ならばs[0]はout of memoryでpanic発生
s != "" && s[0] == 'x'
```

if 1のような評価が暗黙的に行われることはない
もし、このような評価を頻繁に行うのであれば専用の関数を作成する

goの文字列はjava同様不変
不変であることにより、複製のコストが低くなる
何故ならば、複製元が決して変更されないことが保証されているので、複製元を参照すれば良いから。
同様に部分文字列の参照s[7:]も参照元が変更されることがないので、参照元の指定先を読めば良いだけですむ


Unicode ... 文字集合
コードポイント ... 文字集合(Unicode)内で文字に割り振られた位置 U+307B Goではこのコードポイントをルーンともいう
UTF8 ...

Unicodeの基本セットは0x0000~0xFFFFの16bit範囲
追加の特殊な文字を取り扱いたい場合は0xFFFFFFまで拡張される

UTFによって、

文字を打ち込む　-> UTF8を指定してエンコーディングした場合
